using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using DGen.Common;
using DGen.Models;

namespace Go
{
    public class GoWriter : ICodeWriter
    {
        private static readonly Regex ImportRegex = new Regex("goimport (?<imp>.+)");
        private static readonly Regex PackageRegex = new Regex("gopackage (?<pkg>.+)");

        public void Write(ClassDeclInfo declInfo, StreamWriter target)
        {
            target.WriteLine("// This file is generated by CK Schema Compiler. DO NOT EDIT.");
            target.WriteLine();

            WritePackage(declInfo, target);
            WriteImports(declInfo, target);


            target.WriteLine();

            WriteClassDecl(declInfo, target);
            WriteFields(declInfo, target);

            target.WriteLine("}");

            WriteConstructor(declInfo, target);
        }

        private static void WriteClassDecl(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            var name = typeInfo.Name.ToValidTypeName();

            if (typeInfo.Docs.Count > 0)
            {
                writer.WriteLine($"// {name} {typeInfo.Docs[0].RemoveMemberName(name)}");
                for (int i = 1; i < typeInfo.Docs.Count; i++)
                {
                    writer.WriteLine("// " + typeInfo.Docs[i]);
                }
            }

            writer.WriteLine("type " + name + " struct {");
        }

        private static void WriteImports(ClassDeclInfo typeInfo, StreamWriter kotlinWriter)
        {
            var imports = new List<string>();
            foreach (string o in typeInfo.Options)
            {
                Match m = ImportRegex.Match(o);
                if (!m.Success)
                    continue;
                imports.Add(m.Groups["imp"].Value.Trim('"'));
            }

            foreach (string u in imports)
            {
                kotlinWriter.WriteLine("import \"" + u + "\"");
            }
        }

        private static void WritePackage(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            string pkg = null;
            foreach (string s in typeInfo.Options)
            {
                Match m = PackageRegex.Match(s);
                if (!m.Success)
                    continue;

                pkg = m.Groups["pkg"].Value;
                break;
            }

            if (!string.IsNullOrEmpty(pkg))
            {
                writer.WriteLine("package " + pkg);
            }
        }

        private static void WriteFields(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            foreach (var field in typeInfo.Fields)
            {
                string fieldType = field.Type.Replace("?", "");

                string typeResult = TypeMap.GetTypeName(fieldType);

                var name = field.Name.FirstCharToUpper().ToValidTypeName();

                if (field.Docs.Count > 0)
                {
                    writer.Indent().WriteLine($"// {name} {field.Docs[0].RemoveMemberName(field.Name)}");
                    for (int j = 1; j < field.Docs.Count; j++)
                    {
                        writer.Indent().WriteLine($"// {field.Docs[j]}");
                    }
                }

                writer.Indent().WriteLine($"{name} {(field.IsNullable ? "*" : "")}{typeResult} `json:\"{field.Name.FirstCharToUpper()}\"`");
            }
        }

        private static void WriteConstructor(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            var typeName = typeInfo.Name.ToValidTypeName();

            writer.WriteLine($"// New{typeName} creates a new instance of {typeName}");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                if (field.Docs.Count > 0)
                {
                    writer.WriteLine("// ");

                    var name = field.Name.ToValidTypeName();
                    writer.WriteLine($"// {name} {field.Docs[0].RemoveMemberName(field.Name)}");

                    for (int j = 1; j < field.Docs.Count; j++)
                    {
                        writer.WriteLine($"// {field.Docs[j]}");
                    }
                }
            }

            writer.WriteLine("//goland:noinspection ALL");
            writer.Write($"func New{typeName}(");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                string fieldType = field.Type.Replace("?", "");

                string typeResult = TypeMap.GetTypeName(fieldType);

                writer.Write(field.Name.ToValidTypeName());
                writer.Write(" ");

                if (field.IsNullable)
                    writer.Write("*");

                writer.Write(typeResult);
                writer.Write(",");
            }

            writer.WriteLine($") *{typeName} {{");
            writer.Indent().WriteLine($"return &{typeName} {{");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                writer.Indent(2).Write(field.Name.FirstCharToUpper().ToValidTypeName());
                writer.Write(": ");
                writer.Write(field.Name.ToValidTypeName());
                writer.WriteLine(",");
            }

            writer.Indent().WriteLine();
            writer.Indent().WriteLine("}");
            writer.WriteLine("}");
        }
    }
}