using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using DGen.Common;
using DGen.Models;

namespace Go
{
    public class GoWriter : ICodeWriter
    {
        private static readonly Regex ImportRegex = new Regex("goimport (?<imp>.+)");
        private static readonly Regex PackageRegex = new Regex("gopackage (?<pkg>.+)");
        private CmdOptions _options;

        public GoWriter(CmdOptions options)
        {
            _options = options;
        }

        public void Write(ClassDeclInfo declInfo, StreamWriter target)
        {
            target.WriteLine("// This file is generated by DGen Compiler. DO NOT EDIT.");
            target.WriteLine();

            string package = WritePackage(declInfo, target);
            WriteImports(declInfo, target);


            target.WriteLine();

            WriteClassDecl(declInfo, target, package);
            WriteFields(declInfo, target);

            target.WriteLine("}");

            WriteConstructor(declInfo, target, package);

            if (_options.MsgPack)
                WriteMsgPackMethods(declInfo, target, package);
        }

        private void WriteMsgPackMethods(ClassDeclInfo declInfo, StreamWriter target, string package)
        {
            void W(string l)
            {
                target.WriteLine(l);
            }

            string n = GetClassName(declInfo, package);
            
            W($"// Encode encodes the object with MessagePack serialization system");
            W($"func (m *{n}) Encode(buf *bytes.Buffer) error {{");
            W("e := msgpack.NewEncoder(buf)");
            W("e.UseArrayEncodedStructs(true)");
            W("return e.Encode(m)");
            W("}");
            
            W($"// Decode decodes the object with MessagePack serialization system");
            W($"func (m *{n}) Decode(buf *bytes.Buffer) error {{");
            W("d := msgpack.NewDecoder(buf)");
            W("return d.Decode(m)");
            W("}");
        }

        private static void WriteClassDecl(ClassDeclInfo typeInfo, StreamWriter writer, string package)
        {
            string name = GetClassName(typeInfo, package);

            if (typeInfo.Docs.Count > 0)
            {
                writer.WriteLine($"// {name} {typeInfo.Docs[0].RemoveWordFromStart(name)}");
                for (int i = 1; i < typeInfo.Docs.Count; i++)
                {
                    writer.WriteLine("// " + typeInfo.Docs[i]);
                }
            }

            writer.WriteLine("type " + name + " struct {");
        }

        private void WriteImports(ClassDeclInfo typeInfo, StreamWriter kotlinWriter)
        {
            var imports = new List<string>();

            if (_options.MsgPack)
            {
                imports.Add("github.com/vmihailenco/msgpack/v5");
                imports.Add("bytes");
            }

            if (_options.Json)
            {
                imports.Add("encoding/json");
            }
            
            foreach (string o in typeInfo.Options)
            {
                Match m = ImportRegex.Match(o);
                if (!m.Success)
                    continue;

                string v = m.Groups["imp"].Value.Trim('"');

                if(!imports.Contains(v)) 
                    imports.Add(v);
            }

            foreach (string u in imports)
            {
                kotlinWriter.WriteLine("import \"" + u + "\"");
            }
        }

        private static string WritePackage(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            string pkg = null;
            foreach (string s in typeInfo.Options)
            {
                Match m = PackageRegex.Match(s);
                if (!m.Success)
                    continue;

                pkg = m.Groups["pkg"].Value;
                break;
            }

            if (!string.IsNullOrEmpty(pkg))
            {
                writer.WriteLine("package " + pkg);
            }

            return pkg;
        }

        private static void WriteFields(ClassDeclInfo typeInfo, StreamWriter writer)
        {
            foreach (var field in typeInfo.Fields)
            {
                string fieldType = field.Type.Replace("?", "");

                string typeResult = TypeMap.GetTypeName(fieldType);

                var name = field.Name.FirstCharToUpper().ToValidTypeName();

                if (field.Docs.Count > 0)
                {
                    writer.Indent().WriteLine($"// {name} {field.Docs[0].RemoveWordFromStart(field.Name)}");
                    for (int j = 1; j < field.Docs.Count; j++)
                    {
                        writer.Indent().WriteLine($"// {field.Docs[j]}");
                    }
                }

                writer.Indent().WriteLine($"{name} {(field.IsNullable ? "*" : "")}{typeResult} `json:\"{field.Name.FirstCharToUpper()}\"`");
            }
        }

        private static void WriteConstructor(ClassDeclInfo typeInfo, StreamWriter writer, string package)
        {
            var typeName = GetClassName(typeInfo, package);

            writer.WriteLine($"// New{typeName} creates a new instance of {typeName}");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                if (field.Docs.Count > 0)
                {
                    writer.WriteLine("// ");

                    var name = field.Name.ToValidTypeName();
                    writer.WriteLine($"// {name} {field.Docs[0].RemoveWordFromStart(field.Name)}");

                    for (int j = 1; j < field.Docs.Count; j++)
                    {
                        writer.WriteLine($"// {field.Docs[j]}");
                    }
                }
            }

            writer.WriteLine("//goland:noinspection ALL");
            writer.Write($"func New{typeName}(");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                string fieldType = field.Type.Replace("?", "");

                string typeResult = TypeMap.GetTypeName(fieldType);

                writer.Write(field.Name.ToValidTypeName());
                writer.Write(" ");

                if (field.IsNullable)
                    writer.Write("*");

                writer.Write(typeResult);
                writer.Write(",");
            }

            writer.WriteLine($") *{typeName} {{");
            writer.Indent().WriteLine($"return &{typeName} {{");
            foreach (FieldDeclInfo field in typeInfo.Fields)
            {
                writer.Indent(2).Write(field.Name.FirstCharToUpper().ToValidTypeName());
                writer.Write(": ");
                writer.Write(field.Name.ToValidTypeName());
                writer.WriteLine(",");
            }

            writer.Indent().WriteLine();
            writer.Indent().WriteLine("}");
            writer.WriteLine("}");
        }

        private static string GetClassName(ClassDeclInfo typeInfo, string package)
        {
            string strippedName = typeInfo.Name.RemoveWordFromEnd(package).RemoveWordFromEnd(package);
            string name = strippedName.Length > 0
                ? strippedName.ToValidTypeName()
                : typeInfo.Name.ToValidTypeName();
            return name;
        }
    }
}